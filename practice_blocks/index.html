<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<link rel="stylesheet" href="./css/main.css" />
	</head>
	<body>
		<h1>Three.js Blocks</h1>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>

		<script>
			let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			);
			camera.position.z = 4;

			let renderer = new THREE.WebGLRenderer({
				antialias: true,
			});
			renderer.setClearColor("#e5e5e5");
			renderer.setSize(window.innerWidth, window.innerHeight);

			document.body.appendChild(renderer.domElement);

			window.addEventListener("resize", () => {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});

			let raycaster = new THREE.Raycaster();
			let mouse = new THREE.Vector2();

			//form, material(skin)
			// let meshX = -10;
			let meshes = Array.from({ length: 25 }, () => {
				let geometry = new THREE.BoxGeometry(1, 1, 1);
				let matrial = new THREE.MeshLambertMaterial({
					color: 0xf7f7f7,
				});

				return new THREE.Mesh(geometry, matrial);
			});

			meshes.forEach((mesh) => {
				mesh.position.x = (Math.random() - 0.5) * 10;
				mesh.position.y = (Math.random() - 0.5) * 10;
				mesh.position.z = (Math.random() - 0.5) * 10;
				scene.add(mesh);
			});

			// mesh.position.set(2, 2, -2);
			// mesh.rotation.set(45, 0, 0);
			// mesh.scale.set(1, 2, 1);

			let light1 = new THREE.PointLight(0xffffff, 1, 1000);
			light1.position.set(0, 0, 0);
			scene.add(light1);

			let light2 = new THREE.PointLight(0xffffff, 2, 1000);
			light2.position.set(0, 0, 25);
			scene.add(light2);

			let render = function () {
				requestAnimationFrame(render); // consider resizing window
				renderer.render(scene, camera);
			};

			function onMouseMove(e) {
				e.preventDefault();

				mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);

				let intersects = raycaster.intersectObjects(
					scene.children,
					true
				);

				// for (let i = 0; i < intersects.length; i++) {
				if (intersects[0]) {
					intersects[0].object.material.color.set(0x5500cd);
					tl = new TimelineMax();
					tl.to(intersects[0].object.scale, 1, {
						x: 2,
						ease: Expo.easeOut,
					});
					tl.to(intersects[0].object.scale, 0.5, {
						x: 2,
						ease: Expo.easeOut,
					});
					tl.to(intersects[0].object.position, 0.2, {
						x: 1,
					});
					tl.to(
						intersects[0].object.rotation,
						0.5,
						{
							y: Math.PI * 0.5,
							ease: Expo.easeOut,
						},
						"-=1.5"
					);
				}
				// }
			}

			render();

			window.addEventListener("mousemove", onMouseMove);
		</script>
	</body>
</html>
